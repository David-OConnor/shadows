export declare const vsSource = "\n    attribute vec4 position;\n    attribute vec4 normal;\n                   \n    // We can't pass 5x5 homogenous matrices to the shader, but can pass 4x4,\n    // non-homogenous matrices, then translate separately.\n    uniform mat4 u_model;\n    uniform mat4 u_view;\n    uniform mat4 u_proj;\n    \n    uniform vec4 u_shape_position;\n    uniform vec4 u_cam_position;\n    uniform vec4 u_ambient_color;\n    uniform vec4 u_diffuse_color;\n    uniform vec4 u_diffuse_direction;\n    \n    uniform float u_ambient_intensity;\n    uniform float u_diffuse_intensity; \n    \n    uniform float u_color_max;\n    uniform float u_shape_opacity;\n           \n    varying vec4 v_color;\n    \n    vec4 find_fourd_color(vec4 positioned_pt) {\n        float u_dist = u_cam_position[3] - positioned_pt[3];\n\n        float portion_through = abs(u_dist) / u_color_max;\n\n        if (portion_through > 1.) {\n            portion_through = 1.;\n        }\n\n        float base_gray = 0.0;\n        float color_val = base_gray + portion_through;\n        vec4 fourd_color;\n\n        if (u_dist > 0.) {\n            fourd_color = vec4(base_gray, base_gray, color_val, u_shape_opacity);  // Blue\n        } else {\n            fourd_color = vec4(color_val, base_gray, base_gray, u_shape_opacity);  // Red\n        }\n        return fourd_color * u_ambient_intensity;\n    }\n\n    vec4 find_diffuse_color() {\n        vec4 norm = normalize(u_model * normalize(normal));\n        vec4 dir = normalize(u_diffuse_direction);\n        float diffuse_weight = max(dot(norm, dir), 0.);\n        return u_diffuse_color * diffuse_weight * u_diffuse_intensity;\n    }\n\n    void main() {\n        vec4 positioned_pt = (u_model * position) + u_shape_position;\n        positioned_pt = u_view * (positioned_pt - u_cam_position);\n        \n        gl_Position = u_proj * positioned_pt;\n\n        vec4 fourd_color = find_fourd_color(positioned_pt);\n        vec4 diffuse_color = find_diffuse_color();\n\n        v_color = mix(fourd_color, diffuse_color, 0.5);\n    }\n";
export declare const fsSource = "\n    varying highp vec4 v_color;\n\n    void main() {\n        // gl_FragColor is a special name for GLSL ES 1.0\n        gl_FragColor = v_color;\n    }\n";
export declare const vsSkybox = "\n    attribute vec4 a_position;\n    attribute vec2 a_texcoord;\n     \n    uniform mat4 u_matrix;\n     \n    varying vec2 v_texcoord;\n     \n    void main() {\n      // Multiply the position by the matrix.\n      gl_Position = u_matrix * a_position;\n     \n      // Pass the texcoord to the fragment shader.\n      v_texcoord = a_texcoord;\n    }\n";
export declare const fsSkybox = "\n        precision mediump float;\n         \n        // Passed in from the vertex shader.\n        varying vec2 v_texcoord;\n         \n        // The texture.\n        uniform sampler2D u_texture;\n         \n        void main() {\n           gl_FragColor = texture2D(u_texture, v_texcoord);\n        }\n    ";
